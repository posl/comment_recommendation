#问题陈述
#N个人，身份证号码为1，2，...，N，在一家银行门口排队。
#将会有Q个事件。以下三种事件可能发生。
#1 : 出纳员打电话给身份证号码最小的人，他还没有被叫。
#2 x : 身份证号码为x的人第一次来找柜员。(这里，出纳员至少已经叫过x人一次）。
#3 : 出纳员再次呼叫身份证号码最小的人，该人已经被呼叫过，但还没有来。
#在第三种事件中打印出被出纳员叫来的人的身份证号码。
#
#限制条件
#1 ≦ N ≦ 5 × 10^5
#2 ≦ Q ≦ 5 × 10^5
#当所有的人都已经被叫过至少一次时，就不会有第一种事件。
#对于每一个第二类事件，身份证号码为x的人已经被出纳员叫过至少一次。
#对于每一个第二类事件，身份证号码为x的人不会来找出纳员超过一次。
#当所有已经被叫过的人都来找过出纳员时，就不会有第三种事件了。
#至少有一个第三种类型的事件。
#输入的所有数值都是整数。
#
#输入
#输入是由标准输入法提供的，格式如下，其中 event_i 表示第 i 个事件：
#N Q
#事件_1
#事件_2
#.
#.
#.
#事件_Q
#每个事件的描述都是以下格式之一：
#1
#2 x
#3
#
#输出
#打印X行，其中X是第三类事件的数量。
#第i行应包含在第i个第三类事件中被呼叫的人的ID号。
#
#输入样本 1
#4 10
#1
#1
#3
#2 1
#1
#2 3
#3
#1
#2 2
#3
#
#样本输出1
#1
#2
#4
#对于每个i=1，2，...，Q，下面显示的是已经被叫过但在第i个事件之前还没有来的人的集合。
#i=1 : {}
#i=2 : {1}
#i=3 : {1,2}
#i=4 : {1,2}
#i=5 : {2}
#i=6 : {2,3}
#i=7 : {2}
#i=8 : {2}
#i=9 : {2,4}
#i=10 : {4}
#i=3,7,10的事件是第三种，所以你应该打印这些事件的集合中最小的ID号码的人：1, 2, 4.

def 