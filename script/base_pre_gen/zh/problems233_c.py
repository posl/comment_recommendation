#问题陈述
#我们有N个袋子。
#袋子i包含L_i个球。袋i中的第j个球(1≦ j≦ L_i)上面写有一个正整数a_{i,j}。
#我们将从每个袋子里挑出一个球。
#有多少种方法可以挑出球，使挑出的球上所写的数字的乘积为X？
#在这里，我们把所有的球都区分开来，即使上面写着相同的数字。
#
#限制条件
#N ≧ 2
#L_i ≧ 2
#袋中球数的乘积最多为10^5: prod_{i=1}^{N}L_i ≦ 10^5。
#1 ≦ a_{i,j} ≦ 10^9
#1 ≦ X ≦ 10^{18}
#输入的所有数值都是整数。
#
#输入
#输入由标准输入提供，格式如下：
#N X
#L_1 a_{1,1} a_{1,2} ... a_{1,L_1}
#L_2 a_{2,1} a_{2,2} ... a_{2,L_2}
#.
#.
#.
#L_N a_{N,1} a_{N,2} ... a_{N,L_N}
#
#输出
#打印答案。
#
#输入样本 1
#2 40
#3 1 8 4
#2 10 5
#
#样本输出1
#2
#当选择袋1中的第3个球和袋2中的第1个球时，我们有a_{1,3} × a_{2,1} = 4 × 10 = 40。
#当选择袋1中的第2个球和袋2中的第2个球时，我们有a_{1,2} × a_{2,2} = 4 × 10 = 40。× a_{2,2} = 8 × 5 = 40.
#没有其他方法可以使积为40，所以答案是2。
#
#输入样本2
#3 200
#3 10 10 10
#3 10 10 10
#5 2 2 2 2 2
#
#样本输出2
#45
#请注意，我们区分了所有的球，即使上面写着相同的数字。
#
#样本输入3
#3 1000000000000000000
#2 1000000000 1000000000
#2 1000000000 1000000000
#2 1000000000 1000000000
#
#样本输出3
#0
#可能没有办法使产品变成X。

def 