def get_second_player(N, A):
    # 2^N个玩家，标记为1到2^N，将在一个单淘汰的编程比赛中相互竞争。
    # 玩家i的评分是A_i。任何两位选手都有不同的评分，两位选手之间的比赛结果总是评分高的选手获胜。
    # 锦标赛看起来像一棵完美的二叉树。
    # 从形式上看，锦标赛将按以下方式进行：
    # 对于每个整数i=1，2，3，...，N的这个顺序，会发生以下情况。
    # 对于每个整数j（1 ≦ j ≦ 2^{N - i}），在从未输过的玩家中，拥有（2j - 1）-第1个最小标签的玩家和拥有第2j个最小标签的玩家互相进行比赛。
    #
    # 找出将获得第二名的选手的标签，即在最后的比赛中输掉。
    #
    # 限制条件
    # 1 ≦ N ≦ 16
    # 1 ≦ A_i ≦ 10^9
    # A_i是成对的不同。
    # 输入的所有数值都是整数。
    #
    # 输入
    # 输入是由标准输入提供的，格式如下：
    # N
    # a_1 a_2 a_3 ... a_{2^n}
    #
    # 输出
    # 打印将获得第二名的选手的标签。
    #
    # 输入样本 1
    # 2
    # 1 4 2 5
    #
    # 样本输出 1
    # 2
    # 首先，玩家1和2以及玩家3和4之间将有两场比赛。根据评

if __name__ == '__main__':
    get_second_player()