def main():
    N, K = map(int, input().split())
    C = list(map(int, input().split()))
    #print(N, K, C)
    # 問題文の通りに実装すると、O(N*K) となってしまう。
    # 以下のように、
    # 1. K個の連続した要素の中で、重複している要素を削除する
    # 2. 1.で削除した要素の数を数える
    # 3. 1.で削除した要素の数にKを足す
    # というアルゴリズムを考える。
    # この場合、O(N) で実装できる。
    # ただし、Pythonのset()は、O(1)で要素の追加、削除ができるが、
    # O(N)で要素の存在チェックができない。
    # そのため、set()の要素の存在チェックには、set()をlist()に変換し、
    # list()のin演算子を使用する。
    # この場合、O(N)で要素の存在チェックができる。
    # 以上のことを踏まえると、O(N) + O(N) + O(N) = O(N) となる。
    # また、O(N)のアルゴリズムは、Nが大きい場合には、
    # 1秒以内で実行できる。
    # したがって、このアルゴリズムで実装する。
    # また、以下のようなアルゴリズムも考えられるが、
    # 1. K個の連続した要素の中で、重複している要素を削除する
    # 2. 1.で削除した要素の数を数える
    # 3.
